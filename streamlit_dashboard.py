"""Interactive Streamlit dashboard for Amazon furniture review insights.

This app introduces a narrative-driven UI on top of the artifacts generated by the
notebook workflow. Heavy preprocessing stays outside Streamlit; the app reads the
exported TSV/JSON/GZIP files with caching so stakeholders can explore stories quickly.
"""

from __future__ import annotations

import gzip
import json
from pathlib import Path
from typing import Any, Dict, List, Sequence

import pandas as pd
import plotly.express as px
import streamlit as st

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
BASE_DIR = Path(__file__).resolve().parent
DATASET_PATH = BASE_DIR / "amazon_reviews_us_Furniture_v1_00_filtered.tsv"
CLEAN_INSIGHTS_PATH = BASE_DIR / "review_insights_checkpoint_cleaned.json.gz"
CHARTS_DIR = BASE_DIR / "furniture_insight_charts"


# ---------------------------------------------------------------------------
# Data loading helpers
# ---------------------------------------------------------------------------
def _safe_path_readable(path: Path) -> bool:
    return path.exists() and path.is_file()


@st.cache_data(show_spinner=False)
def load_reviews_dataframe(path: Path) -> pd.DataFrame:
    """Load the filtered TSV of Amazon reviews."""
    if not _safe_path_readable(path):
        return pd.DataFrame()

    df = pd.read_csv(
        path,
        sep="\t",
        parse_dates=["review_date"],
        dtype={
            "marketplace": "category",
            "product_category": "category",
            "vine": "category",
            "verified_purchase": "category",
        },
    )
    return df


@st.cache_data(show_spinner=False)
def load_clean_insights(path: Path) -> pd.DataFrame:
    """Load the cleaned insights JSON produced by the notebook pipeline."""
    if not _safe_path_readable(path):
        return pd.DataFrame()

    with gzip.open(path, "rt", encoding="utf-8") as f:
        payload: List[Dict[str, Any]] = json.load(f)

    df = pd.json_normalize(payload)
    rename_map = {
        "review_metadata.review_id": "review_id",
        "review_metadata.star_rating": "star_rating",
        "review_metadata.product_title": "product_title",
        "review_metadata.review_body": "review_body",
    }
    existing_map = {k: v for k, v in rename_map.items() if k in df.columns}
    if existing_map:
        df.rename(columns=existing_map, inplace=True)
    return df


# ---------------------------------------------------------------------------
# Visualization helpers
# ---------------------------------------------------------------------------
def compute_term_counts(df: pd.DataFrame, column: str, top_n: int) -> pd.DataFrame:
    """Explode list-valued columns and aggregate counts."""
    if df.empty or column not in df.columns:
        return pd.DataFrame(columns=["name", "count"])

    exploded = df.explode(column)
    if exploded.empty:
        return pd.DataFrame(columns=["name", "count"])

    series = (
        exploded[column]
        .dropna()
        .astype(str)
        .str.strip()
        .replace("", pd.NA)
        .dropna()
    )
    counts = (
        series.value_counts()
        .head(top_n)
        .rename_axis("name")
        .reset_index(name="count")
    )
    return counts


def render_dynamic_terms(title: str, df: pd.DataFrame, column: str, top_n: int) -> None:
    counts = compute_term_counts(df, column, top_n)
    if counts.empty:
        st.info("No records match the current filters for this section.")
        return

    fig = px.bar(
        counts,
        x="name",
        y="count",
        text_auto=".0f",
        title=None,
    )
    fig.update_traces(marker_color="#2F4F4F", textposition="outside")
    fig.update_layout(
        xaxis_title="",
        yaxis_title="Mentions",
        margin=dict(l=20, r=20, t=10, b=60),
    )
    st.plotly_chart(fig, width="stretch")
    with st.expander("View table"):
        st.dataframe(counts, hide_index=True, width="stretch")


def render_chart_gallery() -> None:
    if not CHARTS_DIR.exists():
        st.info("No exported charts detected yet.")
        return

    chart_files = sorted(CHARTS_DIR.glob("*.png"))
    if not chart_files:
        st.info("PNG charts not found in the expected directory.")
        return

    st.markdown("### Visual Gallery")
    cols = st.columns(2)
    for idx, chart_path in enumerate(chart_files):
        col = cols[idx % 2]
        with col:
            st.image(chart_path.as_posix(), caption=chart_path.name, width="stretch")


def story_image(filename: str, caption: str, narrative: str | None = None) -> None:
    path = CHARTS_DIR / filename
    if path.exists():
        st.image(path.as_posix(), caption=caption, width="stretch")
        if narrative:
            st.markdown(narrative)


def section_header(title: str, subtitle: str | None = None) -> None:
    st.markdown(f"## {title}")
    if subtitle:
        st.caption(subtitle)


# ---------------------------------------------------------------------------
# Filtering helpers
# ---------------------------------------------------------------------------
def apply_filters_to_insights(
    df: pd.DataFrame,
    date_range: Sequence[pd.Timestamp] | None,
    ratings: Sequence[int] | None,
    verified_choice: str,
    vine_choice: str,
    keyword: str,
) -> pd.DataFrame:
    filtered = df.copy()

    if filtered.empty:
        return filtered

    if date_range and "review_date" in filtered.columns:
        start, end = date_range
        filtered = filtered[
            filtered["review_date"].between(pd.to_datetime(start), pd.to_datetime(end))
        ]

    if ratings and "star_rating" in filtered.columns:
        filtered = filtered[filtered["star_rating"].isin(ratings)]

    if "verified_purchase" in filtered.columns and verified_choice != "All":
        target = "Y" if verified_choice == "Verified only" else "N"
        filtered = filtered[filtered["verified_purchase"] == target]

    if "vine" in filtered.columns and vine_choice != "All":
        target = "Y" if vine_choice == "Vine reviewers" else "N"
        filtered = filtered[filtered["vine"] == target]

    if keyword:
        keyword = keyword.lower()
        filtered = filtered[
            filtered["review_body"].fillna("").str.lower().str.contains(keyword)
            | filtered["product_title"].fillna("").str.lower().str.contains(keyword)
        ]

    return filtered


def apply_filters_to_reviews(
    df: pd.DataFrame,
    date_range: Sequence[pd.Timestamp] | None,
    ratings: Sequence[int] | None,
    verified_choice: str,
    vine_choice: str,
    keyword: str,
) -> pd.DataFrame:
    filtered = df.copy()

    if filtered.empty:
        return filtered

    if date_range:
        start, end = date_range
        filtered = filtered[
            filtered["review_date"].between(pd.to_datetime(start), pd.to_datetime(end))
        ]

    if ratings:
        filtered = filtered[filtered["star_rating"].isin(ratings)]

    if verified_choice != "All":
        target = "Y" if verified_choice == "Verified only" else "N"
        filtered = filtered[filtered["verified_purchase"] == target]

    if vine_choice != "All":
        target = "Y" if vine_choice == "Vine reviewers" else "N"
        filtered = filtered[filtered["vine"] == target]

    if keyword:
        keyword = keyword.lower()
        filtered = filtered[
            filtered["review_body"].fillna("").str.lower().str.contains(keyword)
            | filtered["product_title"].fillna("").str.lower().str.contains(keyword)
        ]

    return filtered


# ---------------------------------------------------------------------------
# Streamlit layout
# ---------------------------------------------------------------------------
st.set_page_config(
    page_title="Amazon Furniture Review Insights",
    layout="wide",
    page_icon="üõãÔ∏è",
)

st.title("Amazon Furniture Review Insights Dashboard")
st.markdown(
    """
This dashboard surfaces structured insights extracted from **87k+ Amazon furniture
reviews**. Use the filters on the left to focus on specific cohorts and scan the
top customer sentiments, pain points, and decision drivers that inform market
expansion planning.
"""
)


# Sidebar configuration ------------------------------------------------------
st.sidebar.header("Story Filters")
top_n = st.sidebar.slider("Top N terms to highlight", min_value=5, max_value=30, value=15, step=5)
keyword_filter = st.sidebar.text_input(
    "Keyword filter",
    value="",
    placeholder="Search product names or review text...",
)

# Load datasets --------------------------------------------------------------
reviews_df = load_reviews_dataframe(DATASET_PATH)
clean_insights_df = load_clean_insights(CLEAN_INSIGHTS_PATH)

if not clean_insights_df.empty:
    if "star_rating" in clean_insights_df.columns:
        clean_insights_df["star_rating"] = pd.to_numeric(
            clean_insights_df["star_rating"], errors="coerce"
        ).astype("Int64")

    list_like_columns = [
        "pain_points_clean",
        "positive_aspects_clean",
        "main_themes_clean",
        "purchase_factors_clean",
        "pain_points",
        "positive_aspects",
        "main_themes",
        "purchase_decision_factors",
    ]
    for column in list_like_columns:
        if column in clean_insights_df.columns:
            clean_insights_df[column] = clean_insights_df[column].apply(
                lambda value: value if isinstance(value, list) else ([] if pd.isna(value) else [value])
            )

    if not reviews_df.empty:
        merge_cols = [
            col
            for col in ["review_id", "review_date", "verified_purchase", "vine", "product_category"]
            if col in reviews_df.columns
        ]
        meta_df = reviews_df[merge_cols].copy()
        if "review_date" in meta_df.columns:
            meta_df["review_date"] = pd.to_datetime(meta_df["review_date"])
        clean_insights_df = clean_insights_df.merge(meta_df, on="review_id", how="left")

    if "review_date" in clean_insights_df.columns:
        clean_insights_df["review_date"] = pd.to_datetime(clean_insights_df["review_date"])

pain_col = (
    "pain_points_clean"
    if not clean_insights_df.empty and "pain_points_clean" in clean_insights_df.columns
    else "pain_points"
)
pos_col = (
    "positive_aspects_clean"
    if not clean_insights_df.empty and "positive_aspects_clean" in clean_insights_df.columns
    else "positive_aspects"
)
theme_col = (
    "main_themes_clean"
    if not clean_insights_df.empty and "main_themes_clean" in clean_insights_df.columns
    else "main_themes"
)
purchase_col = (
    "purchase_factors_clean"
    if not clean_insights_df.empty and "purchase_factors_clean" in clean_insights_df.columns
    else "purchase_decision_factors"
)

# Sidebar filters that depend on data ----------------------------------------
if not clean_insights_df.empty:
    rating_options = sorted(
        clean_insights_df["star_rating"]
        .dropna()
        .astype(int)
        .unique()
        .tolist()
    )
else:
    rating_options = (
        sorted(reviews_df["star_rating"].dropna().astype(int).unique().tolist())
        if not reviews_df.empty
        else []
    )

default_ratings = rating_options or [1, 2, 3, 4, 5]
selected_ratings = st.sidebar.multiselect(
    "Star ratings",
    options=default_ratings,
    default=default_ratings,
)
if not selected_ratings:
    selected_ratings = default_ratings

if not reviews_df.empty:
    min_date = reviews_df["review_date"].min().date()
    max_date = reviews_df["review_date"].max().date()
    date_selection = st.sidebar.date_input(
        "Review date range",
        value=(min_date, max_date),
        min_value=min_date,
        max_value=max_date,
    )
    if isinstance(date_selection, tuple) and len(date_selection) == 2:
        selected_date_range = date_selection
    else:
        selected_date_range = (min_date, max_date)
else:
    selected_date_range = None

verified_choice = st.sidebar.selectbox(
    "Purchase status",
    options=["All", "Verified only", "Non-verified"],
)

vine_choice = st.sidebar.selectbox(
    "Vine participation",
    options=["All", "Vine reviewers", "Non-vine"],
)

# Apply filters --------------------------------------------------------------
filtered_clean_df = (
    apply_filters_to_insights(
        clean_insights_df,
        selected_date_range,
        selected_ratings,
        verified_choice,
        vine_choice,
        keyword_filter,
    )
    if not clean_insights_df.empty
    else pd.DataFrame()
)

filtered_reviews_df = (
    apply_filters_to_reviews(
        reviews_df,
        selected_date_range,
        selected_ratings,
        verified_choice,
        vine_choice,
        keyword_filter,
    )
    if not reviews_df.empty
    else pd.DataFrame()
)

# KPI section ----------------------------------------------------------------
section_header("At a Glance")
col1, col2, col3 = st.columns(3)
with col1:
    total_reviews = len(clean_insights_df) if not clean_insights_df.empty else len(reviews_df)
    st.metric("Reviews in View", f"{len(filtered_clean_df):,}" if not filtered_clean_df.empty else "0")
with col2:
    st.metric("Total Reviews Available", f"{total_reviews:,}" if total_reviews else "‚Äî")
with col3:
    avg_rating = (
        filtered_reviews_df["star_rating"].mean()
        if not filtered_reviews_df.empty and "star_rating" in filtered_reviews_df.columns
        else None
    )
    st.metric(
        "Average Star Rating (selection)",
        f"{avg_rating:.2f}" if avg_rating else "‚Äî",
    )

# Story tabs --------------------------------------------------------------
overview_tab, friction_tab, delight_tab, segments_tab, ops_tab = st.tabs(
    [
        "Executive Overview",
        "Reduce Friction",
        "Delight Customers",
        "Segments & Stories",
        "Operations & Follow-up",
    ]
)

with overview_tab:
    section_header("Executive Overview", "Spot macro trends for the current filter slice.")
    st.markdown(
        "Use the filters on the left to change who we are listening to. "
        "The charts below refresh instantly so you can see whether a segment is growing or cooling."
    )
    if filtered_reviews_df.empty:
        st.info("Upload the TSV dataset locally to explore temporal trends.")
    else:
        time_granularity = st.radio(
            "Group timeline by",
            ["Monthly", "Quarterly", "Yearly"],
            horizontal=True,
            key="overview_time_granularity",
        )
        freq_map = {"Monthly": "ME", "Quarterly": "QE", "Yearly": "YE"}
        freq = freq_map[time_granularity]

        resampled = (
            filtered_reviews_df.set_index("review_date")
            .resample(freq)
            .agg(review_count=("review_id", "count"), avg_rating=("star_rating", "mean"))
            .reset_index()
        )

        if resampled.empty:
            st.info("Not enough data to generate a trend for the selected filters.")
        else:
            count_fig = px.line(
                resampled,
                x="review_date",
                y="review_count",
                markers=True,
                labels={"review_date": "Period", "review_count": "Review count"},
            )
            count_fig.update_layout(margin=dict(l=20, r=20, t=40, b=30))
            st.plotly_chart(count_fig, width="stretch")

            rating_fig = px.line(
                resampled,
                x="review_date",
                y="avg_rating",
                markers=True,
                labels={"review_date": "Period", "avg_rating": "Average rating"},
                range_y=[1, 5],
            )
            rating_fig.update_layout(margin=dict(l=20, r=20, t=40, b=30))
            st.plotly_chart(rating_fig, width="stretch")

    story_image(
        "rating_distribution_for_furniture_reviews.png",
        "Rating distribution across the full furniture corpus",
        "Pairs nicely with the filtered charts above‚Äîlook for shifts in the distribution when you tighten the filters to detect polarisation.",
    )
    story_image(
        "sentiment_trend_avg.png",
        "Average sentiment trend (all reviews)",
        "Use this as the control chart; deviations in the filtered cohort indicate emerging signals.",
    )

with friction_tab:
    section_header("Reduce Friction", "Pinpoint issues blocking purchase.")
    st.markdown(
        "The live chart reflects the current filters so you can contrast friction points by cohort. "
        "Leverage the static charts underneath to compare against the entire dataset."
    )
    if filtered_clean_df.empty:
        st.info("Adjust the filters or ensure the cleaned insights file is available to see dynamic pain points.")
    else:
        render_dynamic_terms("Pain Points", filtered_clean_df, pain_col, top_n)

    story_image(
        "pain_points.png",
        "Top-20 pain points (full dataset)",
        "Cross-check this static view with the live chart to see where the cohort over-indexes.",
    )
    story_image(
        "pain_point_trends.png",
        "Pain point mentions over time",
        "If a filtered segment shows steeper growth than this baseline trend, it deserves immediate attention.",
    )

with delight_tab:
    section_header("Delight Customers", "Surface the strengths worth amplifying.")
    st.markdown(
        "See what consistently delights customers in the active filter set, then compare with the broader market to identify differentiators."
    )
    if filtered_clean_df.empty:
        st.info("Adjust the filters to surface positive drivers.")
    else:
        render_dynamic_terms("Positive Aspects", filtered_clean_df, pos_col, top_n)

    story_image(
        "positive_aspects.png",
        "Top positive drivers (full dataset)",
        "Look for overlap or gaps between the filtered slice and the overall population.",
    )
    story_image(
        "positive_aspect_trends.png",
        "Positive aspects trend lines",
        "When a cohort‚Äôs live chart diverges upward, it marks a messaging opportunity.",
    )
    story_image(
        "top20_overview.png",
        "Positive vs negative share across the first 20 features",
        "Helpful for spotting balanced value propositions that resonate across the journey.",
    )

with segments_tab:
    section_header("Segments & Stories", "Translate clusters into personas and playbooks.")
    st.markdown(
        "Explore how pains, delights, and purchase drivers cluster together. Sample real reviews for qualitative colour, "
        "and use the t-SNE map to describe each audience."
    )
    if filtered_clean_df.empty:
        st.info("No segments available for the current filter combination.")
    else:
        cols = st.columns(2)
        with cols[0]:
            render_dynamic_terms("Emerging Themes", filtered_clean_df, theme_col, top_n)
        with cols[1]:
            render_dynamic_terms("Decision Drivers", filtered_clean_df, purchase_col, top_n)

        available_pain_points = sorted(
            {
                item
                for points in filtered_clean_df.get(pain_col, [])
                for item in (points if isinstance(points, list) else [])
            }
        )
        selected_pain = st.selectbox(
            "Filter sampled reviews by pain point",
            options=["(Show all)"] + available_pain_points,
        )

        filtered_df = filtered_clean_df.copy()
        if selected_pain != "(Show all)":
            filtered_df = filtered_df[
                filtered_df[pain_col].apply(lambda values: selected_pain in values if isinstance(values, list) else False)
            ]

        sample_size = st.slider(
            "Sample reviews",
            min_value=5,
            max_value=50,
            value=15,
            step=5,
            key="segments_sample_size",
        )
        sample_df = filtered_df.sample(min(len(filtered_df), sample_size)) if not filtered_df.empty else pd.DataFrame()

        if sample_df.empty:
            st.info("No reviews match the current filter combination.")
        else:
            for _, row in sample_df.iterrows():
                with st.expander(row.get("product_title", "Review")):
                    st.write(f"**Rating:** {row.get('star_rating', 'N/A')} ‚≠ê")
                    st.write(f"**Pain Points:** {', '.join(row.get(pain_col, []))}")
                    st.write(f"**Positive Aspects:** {', '.join(row.get(pos_col, []))}")
                    st.write(f"**Themes:** {', '.join(row.get(theme_col, []))}")
                    st.write(f"**Decision Drivers:** {', '.join(row.get(purchase_col, []))}")
                    st.write("---")
                    st.write(row.get("review_body", "No review text available."))

    story_image(
        "review_clusters_full_tsne.png",
        "t-SNE projection of 87k furniture reviews",
        """
        - **Assembly friction** ‚Äì dense clusters packed with ‚Äúdifficult assembly‚Äù, ‚Äúmissing parts‚Äù, and ‚Äúpoor instructions‚Äù highlight the number-one detractor.
        - **Quality control** ‚Äì neighbouring groupings containing ‚Äúcolor inaccurate‚Äù and ‚Äúarrived damaged‚Äù signal production / QC follow-ups.
        - **Value seekers vs premium stylists** ‚Äì separated pockets of ‚Äúgreat price / low price‚Äù versus ‚Äúbeautiful design / looks expensive‚Äù show differentiated positioning levers.
        - **Comfort & function wins** ‚Äì islands rich in ‚Äúvery comfortable‚Äù, ‚Äúgood storage‚Äù, and ‚Äúsolid wood‚Äù point to strengths worth amplifying in messaging.
        - **Operations halo** ‚Äì smaller blobs anchored by ‚Äúfast shipping‚Äù, ‚Äúwell packaged‚Äù, and ‚Äúreturn handling nice‚Äù showcase logistics excellence.

        Use these narratives to frame roadmap conversations: lead with assembly risk, contrast it with the delight zones, then close with operational quick wins.
        """,
    )

with ops_tab:
    section_header("Operations & Follow-up", "Monitor service levers and supporting visuals.")
    st.markdown(
        "Track operational signals‚Äîshipping speed, packaging quality, and sentiment balance‚Äîto coordinate with fulfilment teams."
    )
    story_image(
        "review_volume_over_time.png",
        "Review volume over time (all reviews)",
        "Pair this with the live overview chart to understand whether the cohort‚Äôs conversation share is expanding.",
    )
    story_image(
        "sentiment_trend_multiline.png",
        "Sentiment trend by rating band",
        "Look for diverging lines when you focus on specific star ratings in the filters.",
    )
    story_image(
        "purchase_decision_factors.png",
        "Purchase decision factors",
        "Great companion to the live decision-driver chart‚Äîuse it to prioritise cross-functional actions.",
    )

# Footer ---------------------------------------------------------------------
st.markdown("---")
st.caption(
    "Built with Streamlit ‚Ä¢ Data sourced from Amazon customer reviews (Furniture category) ‚Ä¢ "
    "LLM-assisted annotations generated 2025-11-02"
)
